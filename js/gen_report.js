// ========================================
// CONFIGURATION
// ========================================
const CONFIG = {
    PDF_PAGE_SIZE: [595.28, 841.89],
    FONTS: {
        TITLE: PDFLib.StandardFonts.HelveticaBold,
        BODY: PDFLib.StandardFonts.Helvetica
    },
    FONT_SIZES: {
        TITLE: 32,
        SUBTITLE: 16,
        BODY: 12,
        SMALL: 10
    },
    COLORS: {
        PRIMARY: '#007bff',
        SUCCESS: '#28a745',
        ERROR: '#dc3545',
        WARNING: '#ffc107'
    },
    MESSAGES: {
        NO_PROJECTS: 'Vui l√≤ng th√™m √≠t nh·∫•t m·ªôt c√¥ng tr√¨nh!',
        NO_CONTENT: 'Kh√¥ng c√≥ n·ªôi dung n√†o ƒë∆∞·ª£c ch·ªçn ƒë·ªÉ t·∫°o b√°o c√°o!',
        SUCCESS: 'B√°o c√°o PDF ƒë√£ ƒë∆∞·ª£c t·∫°o v√† t·∫£i xu·ªëng th√†nh c√¥ng!',
        GENERATING: 'ƒêang t·∫°o b√°o c√°o...',
        GENERATE_BTN: 'üìÑ T·∫°o B√°o c√°o PDF'
    }
};

// ========================================
// CONSTRUCTION ITEMS DATA
// ========================================
const CONSTRUCTION_ITEMS = [
    { key: 'cau', name: 'üåâ C·∫ßu', file: 'data/cau.pdf' },
    { key: 'duong', name: 'üõ£Ô∏è ƒê∆∞·ªùng', file: 'data/duong.pdf' },
    { key: 'conghop', name: 'üï≥Ô∏è C·ªëng h·ªôp ngang ƒë∆∞·ªùng', file: 'data/cong_hop_ngang_duong.pdf' },
    { key: 'congtron', name: 'üï≥Ô∏è C·ªëng tr√≤n ngang ƒë∆∞·ªùng', file: 'data/cong_tron_ngang_duong.pdf' },
    { key: 'dien_nuoc', name: '‚ö°üíß ƒêi·ªán n∆∞·ªõc', file: 'data/dien_nuoc.pdf' },
    { key: 'httn_doc', name: 'üíß H·ªá th·ªëng tho√°t n∆∞·ªõc d·ªçc', file: 'data/httn_doc.pdf' }
];

// ========================================
// UTILITY FUNCTIONS
// ========================================
class Utils {
    /**
     * Lo·∫°i b·ªè d·∫•u ti·∫øng Vi·ªát v√† emoji/k√Ω t·ª± ngo√†i ASCII
     */
    static removeVietnameseTones(str) {
        if (!str) return '';
        
        const vietnameseMap = {
            '√†|√°|·∫°|·∫£|√£|√¢|·∫ß|·∫•|·∫≠|·∫©|·∫´|ƒÉ|·∫±|·∫Ø|·∫∑|·∫≥|·∫µ': 'a',
            '√®|√©|·∫π|·∫ª|·∫Ω|√™|·ªÅ|·∫ø|·ªá|·ªÉ|·ªÖ': 'e',
            '√¨|√≠|·ªã|·ªâ|ƒ©': 'i',
            '√≤|√≥|·ªç|·ªè|√µ|√¥|·ªì|·ªë|·ªô|·ªï|·ªó|∆°|·ªù|·ªõ|·ª£|·ªü|·ª°': 'o',
            '√π|√∫|·ª•|·ªß|≈©|∆∞|·ª´|·ª©|·ª±|·ª≠|·ªØ': 'u',
            '·ª≥|√Ω|·ªµ|·ª∑|·ªπ': 'y',
            'ƒë': 'd',
            '√Ä|√Å|·∫†|·∫¢|√É|√Ç|·∫¶|·∫§|·∫¨|·∫®|·∫™|ƒÇ|·∫∞|·∫Æ|·∫∂|·∫≤|·∫¥': 'A',
            '√à|√â|·∫∏|·∫∫|·∫º|√ä|·ªÄ|·∫æ|·ªÜ|·ªÇ|·ªÑ': 'E',
            '√å|√ç|·ªä|·ªà|ƒ®': 'I',
            '√í|√ì|·ªå|·ªé|√ï|√î|·ªí|·ªê|·ªò|·ªî|·ªñ|∆†|·ªú|·ªö|·ª¢|·ªû|·ª†': 'O',
            '√ô|√ö|·ª§|·ª¶|≈®|∆Ø|·ª™|·ª®|·ª∞|·ª¨|·ªÆ': 'U',
            '·ª≤|√ù|·ª¥|·ª∂|·ª∏': 'Y',
            'ƒê': 'D'
        };

        let result = str;
        
        // Thay th·∫ø c√°c k√Ω t·ª± ti·∫øng Vi·ªát
        Object.entries(vietnameseMap).forEach(([pattern, replacement]) => {
            result = result.replace(new RegExp(pattern, 'g'), replacement);
        });

        // Lo·∫°i b·ªè d·∫•u k·∫øt h·ª£p
        result = result.replace(/[\u0300\u0301\u0303\u0309\u0323]/g, '');
        result = result.replace(/[\u02C6\u0306\u031B]/g, '');
        
        // Lo·∫°i b·ªè emoji v√† k√Ω t·ª± ngo√†i ASCII
        result = result.replace(/[^\x00-\x7F]/g, '');
        
        return result;
    }

    /**
     * T·∫°o t√™n file download v·ªõi timestamp
     */
    static generateFileName() {
        const date = new Date().toISOString().split('T')[0];
        return `Bao_cao_cong_trinh_${date}.pdf`;
    }

    /**
     * T·∫£i xu·ªëng file PDF
     */
    static downloadPDF(pdfBytes, fileName) {
        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }
}

// ========================================
// FILE MANAGER
// ========================================
class FileManager {
    constructor() {
        this.availableFiles = {};
    }

    /**
     * Ki·ªÉm tra v√† kh·ªüi t·∫°o danh s√°ch file c√≥ s·∫µn
     */
    async initializeFiles() {
        const promises = CONSTRUCTION_ITEMS.map(async (item) => {
            try {
                const response = await fetch(item.file);
                this.availableFiles[item.key] = {
                    name: item.name,
                    path: item.file,
                    exists: response.ok
                };
            } catch (error) {
                this.availableFiles[item.key] = {
                    name: item.name,
                    path: item.file,
                    exists: false
                };
            }
        });

        await Promise.all(promises);
    }

    /**
     * Ki·ªÉm tra file c√≥ t·ªìn t·∫°i kh√¥ng
     */
    isFileAvailable(key) {
        return this.availableFiles[key]?.exists || false;
    }

    /**
     * L·∫•y th√¥ng tin file
     */
    getFileInfo(key) {
        return this.availableFiles[key] || null;
    }
}

// ========================================
// PROJECT MANAGER
// ========================================
class ProjectManager {
    constructor() {
        this.container = document.getElementById('projectsContainer');
    }

    /**
     * Th√™m project m·ªõi
     */
    addProject() {
        const projects = this.getAllProjects();
        const newIndex = projects.length + 1;
        
        const projectHTML = this.createProjectHTML(newIndex);
        const projectDiv = document.createElement('div');
        projectDiv.innerHTML = projectHTML;
        projectDiv.firstElementChild.className = 'project-section';
        projectDiv.firstElementChild.id = `project-${newIndex}`;
        
        this.container.appendChild(projectDiv.firstElementChild);
        this.updateProjectNumbers();
    }

    /**
     * T·∫°o HTML cho project
     */
    createProjectHTML(index) {
        const itemsHTML = CONSTRUCTION_ITEMS.map(item => `
            <div class="item-checkbox" onclick="projectManager.toggleItem(this)">
                <input type="checkbox" id="${item.key}-${index}" name="items-${index}" value="${item.key}">
                <label for="${item.key}-${index}">${item.name}</label>
            </div>
        `).join('');

        return `
            <div class="project-header">
                <div class="project-title">C√¥ng tr√¨nh ${index}</div>
                <button class="remove-btn" onclick="projectManager.removeProjectByElement(this)">
                    üóëÔ∏è X√≥a
                </button>
            </div>
            <input type="text" class="project-name-input" placeholder="Nh·∫≠p t√™n c√¥ng tr√¨nh..." id="projectName-${index}">
            <div class="items-grid">
                ${itemsHTML}
            </div>
        `;
    }

    /**
     * X√≥a project theo element
     */
    removeProjectByElement(btn) {
        const project = btn.closest('.project-section');
        if (project) {
            project.remove();
            this.updateProjectNumbers();
        }
    }

    /**
     * X√≥a project theo ID
     */
    removeProject(id) {
        const project = document.getElementById(`project-${id}`);
        if (project) {
            project.remove();
            this.updateProjectNumbers();
        }
    }

    /**
     * Toggle checkbox item
     */
    toggleItem(element) {
        const checkbox = element.querySelector('input[type="checkbox"]');
        checkbox.checked = !checkbox.checked;
        element.classList.toggle('checked', checkbox.checked);
    }

    /**
     * C·∫≠p nh·∫≠t s·ªë th·ª© t·ª± project
     */
    updateProjectNumbers() {
        const projects = this.getAllProjects();
        projects.forEach((project, idx) => {
            const title = project.querySelector('.project-title');
            if (title) title.textContent = `C√¥ng tr√¨nh ${idx + 1}`;
            
            const nameInput = project.querySelector('.project-name-input');
            if (nameInput) nameInput.id = `projectName-${idx + 1}`;
            
            const checkboxes = project.querySelectorAll('.item-checkbox input[type="checkbox"]');
            const labels = project.querySelectorAll('.item-checkbox label');
            
            checkboxes.forEach((cb, i) => {
                const itemKey = cb.value;
                cb.id = `${itemKey}-${idx + 1}`;
                if (labels[i]) labels[i].setAttribute('for', `${itemKey}-${idx + 1}`);
            });
            
            project.id = `project-${idx + 1}`;
        });
    }

    /**
     * L·∫•y t·∫•t c·∫£ projects
     */
    getAllProjects() {
        return document.querySelectorAll('.project-section');
    }

    /**
     * L·∫•y d·ªØ li·ªáu projects ƒë·ªÉ t·∫°o b√°o c√°o
     */
    getProjectsData() {
        const projects = this.getAllProjects();
        return Array.from(projects).map(project => {
            const projectId = project.id.split('-')[1];
            const projectName = document.getElementById(`projectName-${projectId}`).value.trim();
            const checkedItems = project.querySelectorAll('input[type="checkbox"]:checked');
            
            return {
                id: projectId,
                name: projectName,
                items: Array.from(checkedItems).map(item => item.value)
            };
        }).filter(project => project.items.length > 0);
    }
}

// ========================================
// PDF GENERATOR
// ========================================
class PDFGenerator {
    constructor(fileManager) {
        this.fileManager = fileManager;
    }

    /**
     * T·∫°o b√°o c√°o PDF
     */
    async generateReport() {
        const projectsData = projectManager.getProjectsData();
        
        if (projectsData.length === 0) {
            UI.showStatus(CONFIG.MESSAGES.NO_PROJECTS, 'error');
            return;
        }

        UI.setGeneratingState(true);

        try {
            const pdfDoc = await PDFLib.PDFDocument.create();
            let hasContent = false;

            for (const project of projectsData) {
                if (project.name) {
                    await this.addProjectTitlePage(pdfDoc, project.name);
                    hasContent = true;
                }

                for (const itemKey of project.items) {
                    const success = await this.addItemContent(pdfDoc, itemKey, project.name);
                    if (success) hasContent = true;
                }
            }

            if (!hasContent) {
                UI.showStatus(CONFIG.MESSAGES.NO_CONTENT, 'error');
                return;
            }

            const pdfBytes = await pdfDoc.save();
            Utils.downloadPDF(pdfBytes, Utils.generateFileName());
            UI.showStatus(CONFIG.MESSAGES.SUCCESS, 'success');

        } catch (error) {
            console.error('L·ªói khi t·∫°o PDF:', error);
            UI.showStatus(`L·ªói khi t·∫°o PDF: ${error.message}`, 'error');
        } finally {
            UI.setGeneratingState(false);
        }
    }

    /**
     * Th√™m n·ªôi dung t·ª´ file PDF
     */
    async addItemContent(pdfDoc, itemKey, projectName) {
        const fileInfo = this.fileManager.getFileInfo(itemKey);
        
        if (fileInfo && fileInfo.exists) {
            return await this.addExistingPDFContent(pdfDoc, fileInfo);
        } else {
            return await this.addPlaceholderContent(pdfDoc, itemKey, projectName, fileInfo);
        }
    }

    /**
     * Th√™m n·ªôi dung t·ª´ file PDF c√≥ s·∫µn
     */
    async addExistingPDFContent(pdfDoc, fileInfo) {
        try {
            const response = await fetch(fileInfo.path);
            if (response.ok) {
                const existingPdfBytes = await response.arrayBuffer();
                const existingPdf = await PDFLib.PDFDocument.load(existingPdfBytes);
                const copiedPages = await pdfDoc.copyPages(existingPdf, existingPdf.getPageIndices());
                copiedPages.forEach((page) => pdfDoc.addPage(page));
                return true;
            }
        } catch (error) {
            console.error(`L·ªói khi x·ª≠ l√Ω file ${fileInfo.path}:`, error);
        }
        return false;
    }

    /**
     * Th√™m trang placeholder khi kh√¥ng c√≥ file
     */
    async addPlaceholderContent(pdfDoc, itemKey, projectName, fileInfo) {
        const page = pdfDoc.addPage(CONFIG.PDF_PAGE_SIZE);
        const font = await pdfDoc.embedFont(CONFIG.FONTS.BODY);
        
        const itemName = fileInfo ? fileInfo.name : itemKey;
        const cleanItemName = Utils.removeVietnameseTones(itemName);
        const cleanProjectName = Utils.removeVietnameseTones(projectName);
        
        page.drawText(`HANG MUC: ${cleanItemName}`, {
            x: 50,
            y: 750,
            size: CONFIG.FONT_SIZES.SUBTITLE,
            font: font,
        });
        
        page.drawText(`Cong trinh: ${cleanProjectName}`, {
            x: 50,
            y: 720,
            size: CONFIG.FONT_SIZES.BODY,
        });
        
        if (fileInfo) {
            page.drawText(`Loi: Khong the tai file ${fileInfo.path}`, {
                x: 50,
                y: 680,
                size: CONFIG.FONT_SIZES.BODY,
            });
            
            page.drawText(`[File PDF mau khong ton tai hoac khong the truy cap]`, {
                x: 50,
                y: 650,
                size: CONFIG.FONT_SIZES.SMALL,
            });
        } else {
            page.drawText(`[File PDF mau: ${itemKey}.pdf chua co san]`, {
                x: 50,
                y: 680,
                size: CONFIG.FONT_SIZES.BODY,
            });
            
            page.drawText(`Vui long dat file ${itemKey}.pdf vao thu muc data/`, {
                x: 50,
                y: 650,
                size: CONFIG.FONT_SIZES.SMALL,
            });
        }
        
        return true;
    }

    /**
     * T·∫°o trang ti√™u ƒë·ªÅ cho project
     */
    async addProjectTitlePage(pdfDoc, projectName) {
        const [pageWidth, pageHeight] = CONFIG.PDF_PAGE_SIZE;
        const fontSize = CONFIG.FONT_SIZES.TITLE;
        const font = await pdfDoc.embedFont(CONFIG.FONTS.TITLE);
        
        const text = Utils.removeVietnameseTones(projectName.toUpperCase());
        const textWidth = font.widthOfTextAtSize(text, fontSize);
        const textHeight = font.heightAtSize(fontSize);
        
        const x = (pageWidth - textWidth) / 2;
        const y = (pageHeight - textHeight) / 2;
        
        const page = pdfDoc.addPage(CONFIG.PDF_PAGE_SIZE);
        page.drawText(text, {
            x: x,
            y: y,
            size: fontSize,
            font: font,
        });
    }
}

// ========================================
// UI MANAGER
// ========================================
class UI {
    /**
     * Hi·ªÉn th·ªã th√¥ng b√°o tr·∫°ng th√°i
     */
    static showStatus(message, type) {
        const status = document.getElementById('status');
        status.textContent = message;
        status.className = `status ${type}`;
        status.style.display = 'block';
        
        setTimeout(() => {
            status.style.display = 'none';
        }, 5000);
    }

    /**
     * Thi·∫øt l·∫≠p tr·∫°ng th√°i ƒëang t·∫°o b√°o c√°o
     */
    static setGeneratingState(isGenerating) {
        const generateBtn = document.getElementById('generateBtn');
        generateBtn.disabled = isGenerating;
        generateBtn.innerHTML = isGenerating 
            ? `<div class="loading"></div> ${CONFIG.MESSAGES.GENERATING}`
            : CONFIG.MESSAGES.GENERATE_BTN;
    }
}

// ========================================
// GLOBAL INSTANCES
// ========================================
const fileManager = new FileManager();
const projectManager = new ProjectManager();
const pdfGenerator = new PDFGenerator(fileManager);

// ========================================
// GLOBAL FUNCTIONS (for HTML onclick)
// ========================================
window.addProject = () => projectManager.addProject();
window.removeProjectByElement = (btn) => projectManager.removeProjectByElement(btn);
window.removeProject = (id) => projectManager.removeProject(id);
window.toggleItem = (element) => projectManager.toggleItem(element);
window.generateReport = () => pdfGenerator.generateReport();

// ========================================
// INITIALIZATION
// ========================================
async function initialize() {
    await fileManager.initializeFiles();
    projectManager.addProject(); // T·∫°o project ƒë·∫ßu ti√™n
    projectManager.updateProjectNumbers();
}

// Kh·ªüi t·∫°o khi trang load xong
document.addEventListener('DOMContentLoaded', initialize); 